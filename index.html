<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <title>Python Course</title>

        <link rel="stylesheet" href="dist/reset.css">
        <link rel="stylesheet" href="dist/reveal.css">
        <link rel="stylesheet" href="dist/theme/black.css">

        <style>
            a {
                font-size: 15px;
                margin: auto 0 0 auto;
            }
            li {
                font-size: 20px;
                margin-bottom: 20px;
            }
            .container {
                display: flex;
            }
            .col {
                flex: 1;
            }

            .column-list {
                columns: 100px;
            }
        </style>

        <!-- Theme used for syntax highlighted code -->
        <link rel="stylesheet" href="plugin/highlight/monokai.css">
    </head>

    <body>
        <div class="reveal">
            <div class="slides">

        <section>

            <section>
                <div class="container">
                    <div class="col">
                        <img src="./media/logo-nomades.png" alt="" width=150 height=150>
                    </div>
                    <div class="col">
                        <img src="./media/logo-python.png" alt="" width=150 height=150>
                    </div>
                </div>
                <h3 class="r-fit-text">COURS PYTHON AVANCé</h3>
                <h3 class="r-fit-text">Nomades Advanced Technologies</h3>
                <h3 class="r-fit-text">Automne 2021</h3>
            </section>


            <section>
                <div class="container">
                    <!-- <h3 class="r-fit-text">Sergey Platonov</h3> -->
                    <div class="col">
                        <img src="./media/me.jpg" alt="" width=350>
                        <h3>Sergey Platonov</h3>
                    </div>
                    <div class="col">
                        <ul>
                            <li>Etudiant 3ème année HEPIA</li>
                            <li>Ingénierie IT - Logiciels et Systèmes Complexes</li>
                            <li>Expérience en Python: <strong>5 ans</strong>
                                <ul>
                                    <li>HEPIA - langage de choix pour projets</li>
                                    <li>Projets personnels</li>
                                    <li>Pictet Group - solo projet R&D - 9 mois</li>
                                    <li>CCHE Architects - solo projet R&D - 1 année (en cours)</li>
                                    <li>3ème année supervision projets IT à la Junior Entreprise HEPIA</li>
                                </ul>
                            </li>
                            <li>Intérêts
                                <ul>
                                    <li>Data Science</li>
                                    <li>Computer Vision</li>
                                    <li>Signal Processing</li>
                                    <li>Linear Programming (optimisation)</li>
                                    <li>Algorithmes Génétiques</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
            </section>


            <section>
                <h3>Les buts de ce cours</h3>
                <ul>
                    <li>Parcourir ensemble les bases du langage Python3</li>
                    <li>Apprendre à reflechir comme un dev Python</li>
                    <li>Apprendre à structurer le code</li>
                    <li>Prendre des bonnes habitudes lors du codage</li>
                    <li>Concretiser les connaissances avec des exercices/projets</li>
                </ul>
            </section>


            <section>
                <h3>quelques infos pratiques:</h3>
                <ul>
                    <li>Appuyez sur 'O' pour ouvrir/fermer une vue d'ensemble sur tout le cours</li>
                    <li><strong>Télécharger le cours:</strong> git clone https://github.com/maganoegi/nomades_python_autumn_2021_public.git</li>
                    <li><strong>Mettre à jour:</strong> git pull origin master</li>
                </ul>
            </section>


            <section>
                <h3 class="r-fit-text">Let's go learn Python</h3>
            </section>

        </section>


        <section>

            <section>
                <p>A quoi peut bien servir Python?</p>
            </section>


            <section>
                <h3>Python peut être utilisé pour:</h3>
                <ul>
                    <li>Serveur Back End</li>
                    <li>Interfaçage avec d'autres logiciels, permettant construction et intégration des systèmes complexes</li>
                    <li>Communication avec toutes types de bases de données</li>
                    <li>Traîtement de Big Data</li>
                    <li>Machine Learning</li>
                    <li>Systèmes Embarqués</li>
                    <li>en vrai... pour tout...</li>
                </ul>

                <h3 class="r-fit-text">comment cette flexibilité est possible?</h3>

            </section>


            <section>
                <h3 class="r-fit-text">Python est un langage semi-interprété - <a href="https://towardsdatascience.com/how-does-python-work-6f21fd197888">source</a></h3>

                <img src="./media/semii.jpg" alt="">
            </section>


            <section>
                <h3 class="r-fit-text">comment marche-t-elle, cette compilation?</h3>
                <img src="./media/semii2.png" alt="">
                <ul>
                    <li>le bytecode est stocké dans __pycache__/</li>
                    <li>cette "precompilation" est la raison pour laquelle Python a la reputation d'être "lent"</li>
                </ul>
                <!-- <p>le bytecode est stocké dans __pycache__/</p>
                <p>cette "precompilation" est la raison pour laquelle Python a la reputation d'être "lent"</p> -->

            </section>

        </section>


        <section>

            <section>

                <p>Environnements de travail</p>
            </section>


            <section>

                <p>IDE vs Editeurs de texte</p>
                <div class="container">
                    <div class="col">
                        <p><small>IDE - Integrated Development Environment</small></p>
                        <ul>
                            <li>Plus facile pour débuter</li>
                            <li>Tout optimisé pour developper</li>
                            <li>Necessite de l'apprentissage</li>
                            <li>Debuggage peut être plus complex</li>
                            <li>Trop de soutien - dépendance</li>
                        </ul>
                    </div>
                    <div class="col">
                        <p><small>Editeur de texte</small></p>
                        <ul>
                            <li>Facile à mettre en place</li>
                            <li>Plus legers, flexibles</li>
                            <li>Gestion de packages manuelle</li>
                            <li>Prototypage plus façile</li>
                            <li>Force à apprendre le syntaxe</li>
                        </ul>
                    </div>
                </div>
            </section>


            <section>

                <p>IDE et Text Editor Examples</p>

                <div class="container">
                    <div class="col">
                        <p><small>IDE</small></p>
                        <ul>
                            <li>PyCharm</li>
                            <li>Jupyter Notebook</li>
                        </ul>
                    </div>
                    <div class="col">
                        <p><small>Editeur de Texte</small></p>
                        <ul>
                            <li>Visual Studio Code (VSCode)</li>
                            <li>Sublime Text</li>
                            <li>Atom</li>
                            <li>Vim</li>
                        </ul>
                    </div>
                </div>
            </section>


            <section>

                <p>Problèmes fréquents</p>
                <ul>
                    <li>Même Projet - versions Python différentes</li>
                    <li>Même Projet - versions packages différentes</li>
                    <li>Packages intallés globalement - lourd</li>
                </ul>
                <p>Nous allons utiliser Anaconda - toolkit parfait pour début</p>
                <ul>
                    <li>gestion packages</li>
                    <li>gestion environnements</li>
                    <li>format unique pour ce cours</li>
                </ul>
            </section>


            <section>

                <p>Anaconda Setup</p>
                <img src="./media/anaconda.jpg" alt="">
            </section>


            <section>

                <p>Project Setup</p>

                <img src="./media/projsetup.jpg" alt="">
            </section>


            <section>

                <p>Project Setup</p>

                <div class="r-stack">
                    <div class="fragment fade-in-then-out">
                        <p>Navigation interne (cd - cd .. - ls)</p>
                        <img src="./media/condaterm1.png" alt="">
                    </div>

                    <div class="fragment fade-in-then-out">
                        <p>Lister tous les environnements</p>
                        <img src="./media/condaterm2.png" alt="">
                    </div>

                    <div class="fragment fade-in-then-out">
                        <p>Créer nouveau env</p>
                        <img src="./media/condaterm3.png" alt="">
                    </div>

                    <div class="fragment fade-in-then-out">
                        <p>Activer un env</p>
                        <img src="./media/condaterm4.png" alt="">
                    </div>

                    <div class="fragment fade-in-then-out">
                        <p>Lister tous les packages du env</p>
                        <img src="./media/condaterm5.png" alt="">
                    </div>

                    <div class="fragment fade-in-then-out">
                        <p>tester Python</p>
                        <img src="./media/condaterm6.png" alt="">
                    </div>

                    <div class="fragment fade-in-then-out">
                        <p>deactiver le env courant</p>
                        <img src="./media/condaterm7.png" alt="">
                    </div>

                    <div class="fragment fade-in-then-out">
                        <p>Workflow</p>
                        <img src="./media/workflow.jpg" alt="" width="800px">
                    </div>

                    <div class="fragment fade-in">
                        <p>VSCode plugins</p>
                        <img src="./media/vscodesetup.jpg" alt="" width="400px">
                    </div>
                </div>

            </section>

        </section>


        <section>

            <section>

                <p>Semantique</p>

            </section>


            <section>
            <h3>En Python, il n'y a pas d'accolades</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers=''>
        
                # Pas d'accolades comme en JavaScript
                # A la place - un DOUBLE POINT avec INDENTATION
                def incrementer_de_1(x):
                    x += 1
                    return x
                    </code></pre>
            </section>


            <section>
            <h3>En Python, tout est un objet</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers=''>
        
                x = 10
                type(x)
                >>> "int"

                def func(x):
                    return x
                type(func)
                >>> "class"

                class MyClass:
                    pass
                type(MyClass)
                >>> "type"


                    </code></pre>
            </section>


            <section>
            <h3>Ce qui rend Python tres flexible</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers=''>
        
                def func(x):
                    return x

                y = func
                y(10)
                >>> "10"

                # donc notre fonction est considerée comme 
                # un "first-class citizen"
                # nous ouvrant le chemin pour plein de choses utiles
                    </code></pre>
            </section>


            <section>

                <img width=700 src="https://miro.medium.com/max/1400/1*oErPCXv1PFcuuizXqGEEbw.png" alt="">
                <p><a href="https://medium.com/@meghamohan/mutable-and-immutable-side-of-python-c2145cf72747#id_token=eyJhbGciOiJSUzI1NiIsImtpZCI6ImMzMTA0YzY4OGMxNWU2YjhlNThlNjdhMzI4NzgwOTUyYjIxNzQwMTciLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJuYmYiOjE2MzIwOTA0MjQsImF1ZCI6IjIxNjI5NjAzNTgzNC1rMWs2cWUwNjBzMnRwMmEyamFtNGxqZGNtczAwc3R0Zy5hcHBzLmdvb2dsZXVzZXJjb250ZW50LmNvbSIsInN1YiI6IjExMDg3ODY3Nzg3MTU5NzU2MzU5NSIsImVtYWlsIjoicGxhdHNlcmc5NEB5YWhvby5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXpwIjoiMjE2Mjk2MDM1ODM0LWsxazZxZTA2MHMydHAyYTJqYW00bGpkY21zMDBzdHRnLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiaWF0IjoxNjMyMDkwNzI0LCJleHAiOjE2MzIwOTQzMjQsImp0aSI6IjNkNmRmYTkwZDUyY2FjYzdkNTY1MTJkZjMwNjEwYjc2OTczMGJmMGUifQ.vBeFNhDDGvp0LcGEpudiHPU7KzgJgSFh7JxOBq93HCo7MbQVPF2I9i18FBe7XY1lR-Z6IfwOOPwSXcqCrpt_jWKLgUlTbZC_Qm2rxMYTjKxA4olXjiYg4tRJ5D2Pky2kO1E46_FNpkeOYSFKHddV8sNpzAmr5XA4Ep2LQDEMlg22rk-Nm7_Wh3_TxiIcOg5NB8wVk928dR2JgQ6FpXZzrU6Lw2Ar7hJLUtNDVHZ4yfx-En1p2awCB6aH46Y1h-dOfCNdvajex9sckXx5Wru-px0Bn26vqE_h9CYRy143pVec4jSV1AyCDP_-rJghTFtlSUO0KDm72x1WHQdQxSJysQ">source</a></p>
            </section>


            <section>

                <h3>par contre, il faut faire gaffe avec cette flexibilité!</h3>

                <ul>
                    <li>les objets sont de base <strong>MUTABLES</strong>
                        <ul>
                            <li>debugger avec id() et type()</li>
                        </ul>
                    </li>
                    <li>les types sont inferés lors de l'execution
                        <ul>
                            <li>source de bug ENORME</li>
                        </ul>
                    </li>
                </ul>

                <p>nous allons parler des bonnes pratiques en cours de route ;)</p>
            </section>


            <section>
            <h3>Il existe 2 types de commentaires...</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers=''>
        

                # commentaires "de ligne"

                """
                commentaires
                en
                bloc
                """
                    </code></pre>
            </section>


            <section>
            <h3>exemples</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-14|16-29'>
        

                def weird_function(y):
                    """quick explanation on what the function does.
    
                    A more elaborate explanation on what the function
                    does. Here the algorithms can be explained, as 
                    well as other details. This type of comment 
                    is called a DOCSTRING.

                    ARGS:
                        what arguments and types to expect

                    RETURNS:
                        what type and what that value represents
                    """

                    # line comment to explain this step, 
                    # if it's not clear
                    x = y + 1 

                    # generally, AVOID OVER-COMMENTING:
                    # a variable/function name must speak for itself

                    return "".join(map(lambda x : tw.indent(x, INDENT), [
                        SECTION_OPEN,
                        self.contents,
                        SECTION_CLOSE
                    ]))


                    </code></pre>
            </section>


            <section>
                <p>Fonctions et Methodes</p>
            </section>


            <section>
            <h3>exemples</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='4-18|24-36|42-53|60-65|76-86|98-106'>
        
                # ==================================================



                # en Mathématiques:     f(x) = x + 1
                # en Python:            f(x) 

                def f(x):
                    """mot clé DEF designe une fonction. 
                    Incremente de 1. 
                    """
                    x += 1
                    return x

                # appel de fonction avec ARGUMENT POSITIONNEL:
                >>> output = f(1)
                2







                def f(x):
                    """mot clé DEF designe une fonction. 
                    Incremente de 1. 
                    """
                    x += 1
                    return x

                # appel de fonction sans argument réquis:
                >>> output = f()
                "TypeError: func() missing 1 required" 
                "positional argument: x"







                def f(x):
                    """mot clé DEF designe une fonction. 
                    Incremente de 1. 
                    """
                    x += 1
                    return x

                # appel de fonction avec ARGUMENT NOMME:
                >>> output = f(x=2)
                3








                # fonction LAMBDA, sur une ligne
                >>> l = lambda x : x + 1
                >>> l(1)
                2











                # fonction avec nombre variable d'arguments
                def sum_all(*args):
                    result = 0
                    for arg in args:
                        result += arg
    
                    return result
    
                >>> output = sum_all(1, 2, 3, 4, 5, 6, 7, 8, 9)
                45













                # fonction avec somme variable des variables nommées
                def format_greeting(**kwargs):
                    for key, value in kwargs.items():
                        print("My {0} is {1}".format(key, value))

                >>> format_greeting(name="Sergey")
                "My name is Sergey"







                # ==================================================




                    </code></pre>
            </section>


            <section>
                <h3>Variables</h3>
                <div class="container">
                    <div class="col">
                        <ul>
                            <li>Nous permet de stocker des données de types différents</li>
                            <li>n'ont pas de type - contiennent reference vers memoire</li>
                            <li>doivent être affectées pour exister</li>
                            <li>décision sur contenu au run-time</li>
                        </ul>
                    </div>
                    <div class="col">
                        <ul>
                            <li>notations et opérations:
                                <ul>
                                    <li>x += 1</li>
                                    <li>x -= 1</li>
                                    <li>x *= 1</li>
                                    <li>x **= 1</li>
                                    <li>x /= 1</li>
                                    <li>x //= 1</li>
                                    <li>x %= 1</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                </div>
                <h3 class="r-fit-text">Ceci nous permet d'avoir du typage dynamique</h3>

            </section>


            <section>

                <h3 class="r-fit-text">Les variables n'ont pas de type - il faut les voir comme un pointeur générique - <a href="https://towardsdatascience.com/dynamic-typing-in-python-307f7c22b24e">source</a></h3>

                <div class="r-stack">
                    <img class="fragment" src="./media/dynamicT1.jpg" alt="">
                    <img class="fragment" src="./media/dynamicT2.jpg" alt="">
                    <img class="fragment" src="./media/dynamicT3.jpg" alt="">
                    <img class="fragment" src="./media/dynamicT4.jpg" alt="">
                </div>
            </section>


            <section>

                <p>Cependant...</p>
                <p><small>les exemples d'avant étaient de type IMMUTABLE</small></p>
                <p><small>le comportement des types MUTABLES est DIFFERENT !!</small><a href="https://link.medium.com/LJHu58rPGjb">source</a></p>
                <p><small>plus besoin de créer un nouveau espace-mémoire - garde même pointeurs</small></p>
                <div class="container">
                    <div class="col">
                        <ul>Mutables
                            <li>list</li>
                            <li>dict</li>
                            <li>set</li>
                            <li>bytearray</li>
                            <li>custom class</li>
                        </ul>
                    </div>
                    <div class="col">
                        <ul>Immutables
                            <li>numerical types</li>
                            <li>string</li>
                            <li>tuple</li>
                            <li>frozen set</li>
                            <li>bytes</li>
                        </ul>
                    </div>
                </div>
            </section>


            <section>

                <h3 class="r-fit-text">toute une autre histoire pour les variables mutables.. - <a href="https://towardsdatascience.com/dynamic-typing-in-python-307f7c22b24e">source</a></h3>

                <div class="r-stack">
                    <img class="fragment" src="./media/dynamicT5.jpg" alt="">
                    <img class="fragment" src="./media/dynamicT6.jpg" alt="">
                    <img class="fragment" src="./media/dynamicT7.jpg" alt="">
                    <img class="fragment" src="./media/dynamicT8.jpg" alt="">
                </div>
            </section>


            <section>

                <h3>Duck Typing - <a href="https://link.medium.com/CuerPlhEGjb">source</a></h3>
                <p>"It's a duck if it walks like a duck and quacks like duck"</p>
                <p><small class="fragment">Typage dynamique est aussi rendu possible grace à "duck typing"</small></p>
                <p><small class="fragment">TOUT peut devenir TOUT tant qu'on suit la logique suivante:</small></p>

                <ul class="fragment">
                    <li>Pour utiliser une function -> besoin d'un canard</li>
                    <li>Pour être un canard -> faut cancaner et marcher (pas très exigeant...)</li>
                    <li>Du coup, faut implementer ces deux choses pour pouvoir participer.</li>
                    <li>(en "quelque sort" similaire aux interfaces en JAVA...)</li>
                </ul>

            </section>


            <section>
            <h3>exemple conceptuel</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-14|15-18|20-34'>
        
                class Duck:
                    def swim(self):
                        print("I can swim!")
    
                    def quack(self):
                        print("QUAAACK!")

                class RoboticDuck:
                    def swim(self):
                        print("I can swim, but I will break...")
    
                    def quack(self):
                        print("execute Q.U.A.A.A.C.K protocol !")

                class Fish:
                    def swim(self):
                        print("I can swim!!")


                def check_if_duck(animal):
                    animal.quack()
                    animal.swim()

                >>> check_if_duck( Duck() )
                "QUAAACK!"
                "I can swim!"

                >>> check_if_duck( RoboticDuck() )
                "execute Q.U.A.A.A.C.K protocol !"
                "I can swim, but I will break..."

                >>> check_if_duck( Fish() )
                "AttributeError: 'Fish' object has no attribute 'quack'"
                    </code></pre>
            </section>


            <section>

                <p>Il existe deux types d'évaluation en Python:</p>
                <ul>
                    <li>strict (stricte)</li>
                    <li>lazy (paresseuse)</li>
                </ul>

                <p><small><strong>Stricte</strong> calcule immédiatement le résultat sans reflechir</small></p>
                <p><small><strong>Paresseuse</strong> calcule que s'il le faut...</small></p>

            </section>


            <section>
            <h3>strict vs lazy evaluation</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-3|4-12'>
        

                # evaluation stricte, rien d'intéressant...
                x = 0
                x += sum([1, 2])

                class DataBaseManager:
                    ...
                    # example de lazy eval ;) résultats en cache 
    
                    @property 
                    def all_user_accounts(self):
                        # do something insanely LONG and HORRIBLE...
                        return result



                    </code></pre>
            </section>

        </section>


        <section>

            <section>
                <p>Structure du langage</p>

            </section>


            <section>

                <p>Types numériques</p>
                <div class="container">
                    <div class="col">
                        <p>int</p>
                    </div>
                    <div class="col">
                        <p>long</p>
                    </div>
                    <div class="col">
                        <p>float</p>
                    </div>
                    <div class="col">
                        <p>complex</p>
                    </div>
                </div>
                <div class="container">
                    <div class="col">
                        <ul>
                            <li>x + y</li>
                            <li>x - y</li>
                            <li>x * y</li>
                            <li>x / y</li>
                            <li>x // y</li>
                            <li>-x</li>
                        </ul>
                    </div>
                    <div class="col">
                        <ul>
                            <li>abs(x)</li>
                            <li>int(x)</li>
                            <li>float(x)</li>
                            <li>complex(re, im)</li>
                            <li>c.conjugate()</li>
                            <li>pow(x, y)</li>
                            <li>x**y</li>
                        </ul>
                    </div>
                </div>
            </section>


            <section>
            <h3>conversion de type - Casting</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-16|31-38'>
        

                # conversion IMPLICITE
                >>> x = 12 # int
                >>> y = 1.0 # float

                >>> type(x * y)
                float

                >>> type(x % y)
                float

                # Pourquoi?

                >>> type("Hello World" + x)
                TypeError
















                # conversion EXPLICITE
                >>> x = 1.0
                >>> y = int(x)
                >>> type(y)
                int

                >>> str(x)
                '1.0'











                    </code></pre>
            </section>


            <section>
            <h3>type string</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-3|5-7|9-11|13-18|20-28|30-40'>
        
                # Ceci est un string...
                >>> hello = "Hello"
                >>> world = 'World'

                # Strings peuvent subir des opérations...
                >>> combined_string = hello + world
                "HelloWorld"

                # strings peuvent être formatées...
                >>> formatted_string = f"{combined_string} misses a space..."
                "HelloWorld misses a space..."

                >>> list_of_strings = [
                ...     "hello",    
                ...     "world"   
                ... ]
                >>> " ".join(list_of_strings).upper()
                "hello world"

                # strings peuvent être considerées comme des listes...
                >>> first_char = formatted_string[0]
                "H"

                >>> len(first_char)
                1

                >>> 'Python' in formatted_string
                False

                # ... mais ils ont aussi des methodes propres...
                >>> combined_string.upper()
                'HELLOWORLD'

                >>> combined_string.lower()
                'helloworld'

                >>> "hello world         ".strip()
                "hello world"

                # les '' peuvent être utilisées à l'intérieur de ""
                    </code></pre>
            </section>


            <section>
            <h3>boolean et operateurs</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-11|13-23'>
        
                # valeur booléenne
                >>> lower = 12 # variable de type immutable...
                >>> higher = 13
                >>> lower < higher
                True

                >>> lower >= higher
                False

                >>> 12 == 12.0 # comparaison par reference...
                True 

                >>> x = True
                >>> y = False

                >>> x and y
                False

                >>> x or y 
                True

                >>> x ^ y # xor (or exclusif)
                True
                    </code></pre>
            </section>


            <section>

                <h3>Listes</h3>

                <ul>
                    <li>collection clé du langage</li>
                    <li>variable MUTABLE - ATTENTION BUGS</li>
                    <li>iterable</li>
                    <li>indexable</li>
                    <li>plein de modes d'exploitation, car important!</li>
                </ul>

                <p>Regardons les exemples pour commencer...</p>
            </section>


            <section>
            <h3>Listes - base</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-2|4-6|8-14|18-23|27-29|32-47'>
        
                # initialisons une liste...
                >>> lst = []

                # ajoutons quelque chose...
                >>> lst.append(12)
                [12]

                # et encore, mais de type different...
                >>> lst.append("douze")
                [12, "douze"]

                # ATTENTION: ne faites jamais ça s'il vous plaît...
                # et S'IL FAUT le faire, utilisez les TUPLES:
                >>> t = (12, "douze")



                # listes sont ITERABLES...
                # donc on peut les parcourir par valeur
                >>> for value in lst:
                ...     print(value) 
                12
                "douze"



                # elles sont aussi indexables...
                >>> lst[0]
                12


                # et on peut avoir des listes dans listes
                >>> nested = [
                ...     ["uno", "dos", "tres"], 
                ...     ["eins", "zwei", "polizei"],
                ...     ["bonjour"]   
                ... ]

                >>> silly_phrase = [
                ...     nested[2][0],
                ...     nested[0][1],
                ...     nested[1][2]
                ... ]

                >>> " ".join(silly_phrase)
                "bonjour dos polizei"



                "=============="

                    </code></pre>
            </section>


            <section>
            <h3>Listes - avance</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-11|13-18|20-30|32-38|40-43|45-46|48-52|54-65'>
        
                # SLICING - lst[start : stop : step]
                >>> lst = [1, 2, 3, 4, 5, 6, 7, 8]

                >>> lst[:]
                [1, 2, 3, 4, 5, 6, 7, 8]

                >>> lst[1:]
                [2, 3, 4, 5, 6, 7, 8]

                >>> lst[::-1] # debut à la fin avec un pas négatif
                [8, 7, 6, 5, 4, 3, 2, 1]

                >>> lst = "HWeolrllod"
                >>> lst[::2] # pas de 2, commençant par index 0
                "Hello"

                >>> lst[1::2] # pas de 2, commençant par index 1
                "World"

                # prendre le dernier et avant-dernier element
                # et additionner les deux
                >>> lst = [1, 2, 3, 4, 5, 6, 7, 8]
                >>> lst[-1] + lst[-2]
                15
                # recherche d'index...
                >>> lst.index(3)
                2

                >>> lst.index(15)
                ValueError

                # Comprehension des Listes
                # manière de composer des nouveaux listes
                # a partir des "règles" et boucles FOR imbriquées.

                # PLUS RAPIDE, "MEMORY SAFE", FACILE A LIRE
                >>> lst = [0, 1, 2, 3, 4, 5, 6]
                >>> lst_squared = [x**2 for x in lst]

                # Qu'est-ce qu'il se passe?

                # parcours de liste LST par valeur...
                >>> lst_squared = [___ for x in lst]

                # accès a la variable x  dans le scope...
                >>> lst_squared = [x___ for x in lst]

                # elevation de la variable (valeur de lst) en carré
                >>> lst_squared = [x**2 for x in lst]

                # NOTE: les [] autour signifient qu'on construit une liste
                # et non une dictionnaire -> ce serait alors des {}

                # Fonctions sur des listes...
                >>> lst = [0, 1, 2, 4, 5, 6, 3]

                # tri
                >>> sorted_list = sorted(lst)

                # reverse
                >>> rev_list = reversed(lst)

                # la somme de tous les elements
                # ATTENTION: marche que pour objets avec + defini...
                >>> total = sum(lst)




                    </code></pre>
            </section>


            <section>
            <h3>Flux d'execution</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-13|15-22|26-30|34-47|51-65|67-70 '>
        
                def scream_the_type(number):
                    this_type = type(number)
                    if this_type == int:
                        print("THIS IS AN INT!!!")
    
                    elif this_type == float:
                        print("THIS IS A FLOAT")

                    else:
                        print("This is some other type.... might be a string?")

                >>> scream_the_type("this is not a number")
                "This is some other type.... might be a string?"

                >>> x = 0
                >>> result = []
                >>> while x != 10:
                ...     result.append(x)
                ...     x += 1

                >>> print(result)
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]



                # pattern que l'on trouve dans du code materiel...
                while True:
                    # do something
                    if stop_condition:
                        break



                # pattern que l'on trouve dans du code analytique...
                while condition:

                    if do_condition:
                        # do something

                    elif skip_condition:
                        continue

                    elif stop_condition:
                        break

                    else:
                        pass # do NOTHING



                # boucle FOR - (quand nombre iterations connu)...

                lst = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

                # parcourir une liste en longueur...
                for i in range(len(lst)):
                    print(lst[i])

                # range donne un ITERATEUR de 0 à 9 
                # mais vu que LIST est deja un ITERABLE... 

                # parcourir la liste par valeur...
                for value in lst:
                    print(value)


                # parcourir la liste avec indice et valeur...
                for i, value in enumerate(lst):
                    print(f"value {value} at index {i}")


                    </code></pre>
            </section>


            <section>
            <h3>exemple - calculatrice</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='44|45-47|1-11'>
        



                def ask_user_int(prompt):
                    result = None
                    while not result:
                        try:
                            result = int(input(prompt))

                        except:
                            print("Please provide an integer value")
                            continue
    
                    return result

                def ask_user_op(prompt):
                    result = None
                    while not result:
                        raw = input(prompt)
                        if raw in ["*", "//", "-", "+", "/", "%"]:
                            result = raw
                        else:
                            print("Please select from the following values: \
                                    * / // % + -")
                            continue

                    return result

                def select_operation(op_str):
                    if op_str == "*":
                        return lambda x, y : x * y

                    elif op_str == "/":
                        return lambda x, y : x / y

                    elif op_str == "//":
                        return lambda x, y : x // y

                    elif op_str == "-":
                        return lambda x, y : x - y

                    elif op_str == "+":
                        return lambda x, y : x + y

                    else:
                        return lambda x, y : x % y

                if __name__ == '__main__':
                    left = ask_user_int("First Number: ")
                    op_str = ask_user_op("Operation: ")
                    right = ask_user_int("Second Number: ")
    
                    operation = select_operation(op_str)

                    result = operation(left, right)

                    print(f"{left} {op_str} {right} = {result}")
                    </code></pre>
            </section>


            <section>
            <h3>Expression ternaire</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers=''>
        
                # Expression "simple"...
                age = 37
                if age >= 18:
                    print("la personne est majeure")
                else:
                    print("la personne est mineure")

                # expression ternaire...
                state = 'majeure' if age >= 18 else 'mineure'
                print(f"la personne est {state}")

                # Permet de faire un test rapide sur 
                # une condition simple...

                    </code></pre>
            </section>

        </section>


        <section>

            <section>

                <p>Structures avancees</p>
            </section>


            <section>
            <h3>Tuples</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-8|10-21|23-35|37-43'>
        
                # Tuples sont des objets IMMUTABLES 
                # Donc Memory-safe et plus rapides
                >>> film = ("Good Will Hunting", "Robin Williams", 
                        "Matt Damon", "Ben Affleck", 1997)

                # les tuples sont ITERABLES et INDEXABLES
                >>> film[0]
                "Good Will Hunting"

                # ... peuvent etre decomposées dans variables separees
                name, actor1, actor2, actor3, year = film

                # mais aussi mettre les parties dans des lists..
                name, *actors, year = film

                # quand une valeur ne nous importe pas...
                name, *actors, _ = film

                # quand une fonction retourne plusieurs valeurs,
                # python les met dans un tuple.
                name, *actors, _ = get_random_film()

                # ====== TUPLES NOMMEES ======
                >>> from collections import namedtuple
                >>> Student = namedtuple("Student", [
                    "first_name",
                    "last_name",
                    "school"
                ])

                >>> s1 = Student(
                    first_name="Sergey", 
                    last_name="Platonov",
                    school="Nomades"
                )

                # tuples nommes nous permettent d'avoir:
                    # liaisons clé - valeur (comme dictionnaires)
                    # indexation et itération (comme lists)
                    # champs (comme classes)
                    # immutabilité (comme tuples)

                # elles forment donc un type hyper versatil
                    </code></pre>
            </section>


            <section>
            <h3>Dictionnaires</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-11|13-18|20-30|32-38|40-51|53-61'>
        
                # dictionnaires dont des structures
                # de donnes avec les proprietés suivantes:
                    # jeux de clé-valeur
                    # garantie d'unicité de clés
                    # rapidité de lookup (voir hashtable)

                >>> my_dict = {
                    "key_a" : "val_a",
                    "key_b" : "val_b",
                    "key_c" : "val_c",
                }

                # elles ne sont donc pas indexables ni iterables
                # comme les tuples nommes.
                # Leur but principal est d'assurer une valeur de clé
                # unique...
                >>> my_dict["key_c"]
                "val_c"

                # ajouter un nouveau item unique...
                >>> my_dict["key_x"] = "val_x"

                # ATTENTION:
                #   ajour d'élément avec le meme clé 
                #   va overrride l'élément
                >>> my_dict["key_a"] = "another a value"

                # prendre tous les clés...
                >>> my_dict.keys()
                dict_keys(["key_a", "key_b", "key_c"])

                # prendre tous les items...
                >>> my_dict.items()
                dict_items([("key_a", "val_a"), (...), (...)])

                # prendre toutes les valeurs
                >>> my_dict.values()
                dict_values([..., ..., ...])

                # les dictionaires peuvent être crées...
                >>> my_dict = {
                    "key_a" : "val_a",
                }

                >>> my_dict = dict([("key_a", "val_a")])

                >>> my_dict = dict(key_a="val_a", ...)

                # mais aussi avec Dict Comprehensions...
                >>> my_dict = {x : x**2 for x in (0, 1, 2, 3)}
                {0: 0, 1: 1, 2: 4, 3: 9}

                # parfois une valeur n'existe pas dans un dict...
                >>> d = dict(a=1, b=2, c=3)
                >>> d["d"]
                KeyError: 'd'

                # Il faut alors proposer une valeur par défaut.
                >>> d = dict(a=1, b=2, c=3)
                >>> d.get("d", "ma valeur par defaut")
                "ma valeur par defaut"

                    </code></pre>
            </section>


            <section>
            <h3>Iterateurs</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-14|20-27|29-40|42-54'>
        
                # pour des raisons de memoire et performance
                # certaines fonctions retournent des ITERATEURS...

                # appliquer my_func à chaque element dans la collection..
                >>> map(my_func, [0, 1, 2, 3])
                map object

                # avoir un iterateur de 0 à 9...
                >>> range(10)
                range object

                # filtrer les valeurs dans une collection...
                >>> filter(lambda x : x % 2 == 0, [0, 1, 2, 3, 4, 5])
                filter object

                # Ces elements-là sont des iterateurs intermediaires
                # qui nous permettent de les utiliser par la suite
                #  et enchainer des operations...

                # Enchainement: 
                map(operation, iterator1, ..., iteratorN) -> iterator

                >>> r = reversed(0, 1, 2, 3, 4)
                >>> m = map(pow, r, range(10))
                >>> list(m)
                [1, 3, 4, 1, 0]


                # EXEMPLE:
                >>> def myfunc(a, b):
                ...     return a + b

                >>> m = map(myfunc, [0, 1, 2, 3])
                >>> # PAS D'ERREUR!
                >>> list(m)
                TypeError: missing 1 required positional argument 'b'

                # Donc on voit que MAP effectue uniquement les liens
                # en preparant le contenu à la sortie...
                # ceci est la definition d'un iterateur

                # Le mapping devient "concret", quand:
                >>> list(m)
                # OU
                >>> m.__next__()

                # Les itérateurs importants:
                map(func, *collections)
                reversed(collection)
                zip(*collections)
                filter(predicate, collection)

                # comme c'est des "recettes", on ne peut pas les
                # comparer directement... il faut de la logique en plus 

                # par contre, quand on parcours un objet MAP
                # on ne pourra plus l'utiliser...
                >>> lst = [0, -1, -2, -3, -4]
                >>> m = map(lambda x : abs(x), lst)
                >>> list(m)
                [0, 1, 2, 3, 4]
                >>> list(m)
                []

                # Pourquoi?
                # C'est parce que l'objet map est aussi un GENERATEUR.
                # L'optimisation lui permet de stocker les "recettes" de 
                # generation, mais on peut l'instantier qu'une fois.
                # NOTE: tout generateur est aussi un iterateur.



                    </code></pre>
            </section>


            <section>
            <h3>Generators</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-12|9-22|26-36|38-50'>
        
                # jusqu'à maintenant nous avons appellé les objets ayant ce
                # comportement les ITERATEURS. Plus etre plus specifique, ils
                # s'appellent des GENERATEURS et forment un sous-type des iterateurs.

                # ITERATEURS:
                    # implementent les methodes __iter__() et __next__()
                        # on peut donc les parcourir

                # GENERATEURS
                    # sont des iterateurs
                    # nous donnent le contrôle sur le mémoire
                        # grâce au mot-clé YIELD

                def my_generator(n):
                    for i in range(1, n, 2):
                        yield i**3

                >>> for i in my_generator(10):
                ...     print(i)
                1
                27
                125
                343
                729

                # une autre manière de créer un generateur est avec une 
                # expression generatrice. Syntaxe est similaire à une 
                # comprehension de liste...
                >>> gen = (i**3 for i in range(1, 10, 2))
                generator object

                >>> list(gen)
                [1, 27, 125, 343, 729]

                >>>list(gen)
                []

                # Quand nous utilisons une fonction pour declarer un generateur
                # nous reinitialisons ce dernier à chaque fois. # TODO length
                # Si on le fait avec une expression - il sera epuisé.

                >>> next(my_generator)
                1 
                ......
                >>> next(my_generator)
                729
                >>> next(my_generator)
                StopIteration error # A EVITER!

                # le boucle for les capture de base, nous devons le faire nous-meme
                    </code></pre>
            </section>


            <section>
            <h3>Set & Set Theory</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers=''>
        
                # d'après la théorie des ensembles en maths
                # (SET THEORY), nous avons aussi le type set...
                >>> my_set = {1, 2, 3, 4, 5}

                # la particularité de ce type est l'unicité des valeurs
                # ainsi que les caracteristiques se SET Theory:
                >>> s1 = {1, 2, 3}
                >>> s2 = {1, 2}
                >>> s3 = {4, 5, 6}

                >>> s2 <= s1
                True # car s2 est un sous-ensemble de s1
                >>> s2 <= s3
                False # car s2 n'est pas un sous-ensemble de s3
                    </code></pre>
            </section>

        </section>


        <section>

            <section>

                <p>Comment organiser son code?</p>
            </section>


            <section>

                <p>Un module contient des elements que l'on veut inclure dans notre codebase:</p>
                <ul>
                    <li>fonctions</li>
                    <li>definitions</li>
                    <li>classes</li>
                    <li>constantes</li>
                </ul>

                <p>il existent 2 types de modules:</p>
                <ul>
                    <li>Custom modules - nos fichiers .py</li>
                    <li>Built-in modules - les modules natifs, qui aident à developper</li>
                </ul>
            </section>


            <section>
            <h3>Modules</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-5|7-19|22-30|32-38|40-42'>
        
                # importer un built-in module:
                import random

                >>> random.randint(0, 10)
                8

                # Importer custom module.

                # DANS lib.py .....
                def func():
                    pass

                def other_func():
                    pass

                # DANS __main__.py .....
                import lib

                >>> a = lib.func()


                # Nous pouvons aussi importer la fonction elle-même...
                from lib import other_func

                >>> a = other_func()

                # ainsi que la renommer...
                import lib as thebestLIBever
                # ou alors
                from lib import other_func as the_best_f

                # ATTENTION - bonne pratique:
                    # évitez d'importer la fonction - importez le module.
                        # rend les sources du code clair.
    
                    # quand vous renommez le module avec AS
                    # verifiez quels sont les noms standards
                    # pour ce module.

                # Pour rendre des fonctions PRIVEES, ajoutez un _
                def _private_function():
                    pass
                    </code></pre>
            </section>


            <section>

                <h3>Package</h3>

                <p>Un package est une collection de modules. On peut donc
                    le considerer comme une librairie plus complète.</p>

                <p>La structure du package (dossier) est simple:</p>
                <ul>
                    <li>vos fichiers .py (modules)</li>
                    <li>un fichier __init__.py (souvent vide) pour declaration</li>
                </ul>
            </section>


            <section>

                <p>Structure d'un package - ici en bleu</p>

                <img src="./media/packageTree.png" alt="">

            </section>

        </section>


        <section>

            <section>

                <p>Objets et Classes</p>
            </section>


            <section>

                <p>
                    Pourquoi utiliser classes?
                </p>
                <ul>
                    <li>cacher l'implementation (abstraction)</li>
                    <li>meilleure lisibilité de votre code</li>
                    <li>portabilité</li>
                    <li>extensibilité</li>
                    <li>maintenabilité</li>
                    <li>construction des comportements complexes</li>
                    <li>expression des concepts plus abstraits/réels</li>
                </ul>

                <p>quelle est la différence?</p>

                <ul>
                    <li><strong>Class</strong> - un "dessin" de l'objet</li>
                    <li><strong>Objet</strong> - une version crée à partir du "dessin"</li>
                </ul>



            </section>


            <section>
            <h3>Exemple pour commencer</h3>
            <pre><code class='language-python' data-trim data-noescape                     data-line-numbers='1-11|13-20|22-25|26-37|39-52|54-56|58-71|73-80'>
        
                class Person:
                    def __init__(self, fname: str, age: int):
                        """CONSTRUCTEUR
        
                        Dicte comment un objet doit être construit.
        
                        self : mot clé designe appartenance à un objet
                        self._age : champ privé "_" propre à un objet
                        fname & age : deux valeurs à stocker"""
                        self._fname = fname
                        self._age = age

                    @property
                    def fname(self) -> str:
                        """GETTER
        
                        self : mot clé designe appartenance à un objet
                        self._fname : champ privé "_" propre à un objet 
                        @property : lazy-loading and readability"""
                        return self._fname

                    @property
                    def age(self) -> int:
                        return self._age

                    def __str__(self) -> str:
                        """Built-in method override

                        vue que tout en python est un objet, ils 
                        contiennent deja des comportements par défaut.
                        Il faut alors les "Override" - réecrire.

                        Là - le comportement de transformation en string.
        
                        self : mot clé designe appartenance à un objet"""
                        return f"Person(fname='{self.fname}', \
                                        age='{self.age}')"

                    def __eq__(self, other: Person) -> bool:
                        """Built-in method override

                        vue que tout en python est un objet, ils 
                        contiennent deja des comportements par défaut.
                        Il faut alors les "Override" - réecrire.

                        Là - le comportement de comparaison.

                        self : mot clé designe appartenance à un objet"""
                        return (
                            self.fname == other.fname and 
                            self.age == other.age
                        )

                    def say_hi(self) -> None:
                        """Custom method, proper to the object (self)"""
                        print(f"Hi! my name is {self.fname}!")

                    @classmethod
                    def calculate_age_difference_between(
                        cls, 
                        p1: Person, 
                        p2: Person
                    ):
                        """CLASS METHOD

                        methode qui n'apartient à aucun objet.
                        mais plutot a des classes.

                        au lieu de self, contient CLS comme argument. 
                        """
                        return abs(p1.age - p2.age)

                if __name__ == '__main__':
                    mike = Person("Mike", 27)
                    anna = Person(age=25, fname="Anna")

                    mike.say_hi()
                    anna.say_hi()

                    age_diff = Person.calculate_age_difference_between(mike, anna)

    
                    </code></pre>
            </section>


            <section>

                <p>3 piliers de la programmation orienté objet:</p>

                <ul>
                    <li>
                        <strong>Encapsulation</strong> - cacher des détails d'implémentation
                        <ul>
                            <li>champs privés - cohérence</li>
                            <li>on choisit quelles fonctionnalités nous exposons</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Héritage</strong> - Promouvoir réutilisation code.
                        <ul>
                            <li>Même si mauvaise pratique en général (faut pas abuser avec)</li>
                            <li>Utile pour creer familles et hierarchies...</li>
                        </ul>
                    </li>
                    <li><strong>Polymorphisme</strong> - Même objet peut prendre plusieurs formes</li>
                </ul>
            </section>


            <section>

                <p>Heritage</p>

                <ul>
                    <li>Nous permet de "generaliser" des traits/comportements</li>
                    <li>Crée un lien très fort entre des entités
                        <ul>
                            <li>faut faire attention lors de conception</li>
                            <li>prioritisez la composition! (prochain cours)</li>
                        </ul>
                    </li>
                </ul>
            </section>

        </section>

    </div>
    	</div>
        <script src="dist/reveal.js"></script>
        <script src="plugin/notes/notes.js"></script>
        <script src="plugin/markdown/markdown.js"></script>
        <script src="plugin/highlight/highlight.js"></script>
        <script>
            // More info about initialization & config:
            // - https://revealjs.com/initialization/
            // - https://revealjs.com/config/
            Reveal.initialize({
                hash: true,
                parallaxBackgroundImage: 'https://background-tiles.com/overview/black/patterns/large/1035.png',
                parallaxBackgroundSize: '300px 300px',
                parallaxBackgroundHorizontal: 200,
                parallaxBackgroundVertical: 50,

                // Learn about plugins: https://revealjs.com/plugins/
                plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
            });
        </script>
    </body>
</html>